---
title: "Analysis and Figures for Gallego et al, 2020"
author: "Ramon Gallego"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F)
```

## Intro

This Markdown will make the part of the analysis that goes in the Manuscript: The starting point are the Abundance Table (number of reads per ASV per sample) and the key file (the ASV file has the Hash of the sequences, and the key has the actual DNA sequence). 
If you want to process the raw fastq files to obtain these two files, you have to use the pipeline available in http::/github.com/ramongallego/demultiplexer_for_dada2



```{r libraries and custom functions, echo = F, message=F}
library (RColorBrewer)
library (patchwork)
library (rstanarm)
library (fitdistrplus)
library (ggridges)
library (ggforce)
library (tidyverse)
library (concaveman)
library (vegan)
library (lubridate)
library (ggrepel)
library (factoextra) # Needed for visualizing clusters in Fig2
library (nnet) # Needed for multinomial regression in Fig 2
library (here)
library (conflicted)

conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")
conflict_prefer("area", "patchwork")
#functions for future Salish Sea
models <- readRDS(here("Input","finalModel_20200807.RDS"))

source(here("Scripts","Future_climate_conditions.R"))


source(here("Scripts","tibble.to.matrix.r"))




```

## Datasets to use

To begin with: the ASV.by.taxa dataset and the environmental data (Updated salinity, DIC and pH). 

### Present day datasets

```{r loading data}
data.plankton <- read_csv(here("Input","Combined_Biol_Env_Plankton.csv"))

data.plankton %>% filter(!str_detect(taxa, "Phasianidae|Laridae")) %>% 
  filter (!str_detect(taxa, "Rhodomelaceae")) -> data.plankton

# How to go from real data from standardized data and back
value2std <- function(df){lm(std~value, data = df)}
std2value <- function(df){lm(value~std, data = df)}

stds_to_value <- data.plankton %>% 
  select(sample = event, Area, mean.TA, mean.DIC = mean.DIC.new.sal,Salinity = Salinity.new ,Temperature, Omega.aragonite, pH = pH_new ) %>% 
  distinct() %>%  
  filter(pH > 7.4) %>% 
  ungroup() %>% 
  pivot_longer(cols = c(-sample, -Area),
               names_to = "key",
               values_to = "value") %>% 
          group_by(key, Area) %>%   #calculating different scale for each area; standardizing to different means
          mutate(std = vegan::decostand(value, method = "standardize")) %>%  
          ungroup() %>% 
          mutate(Area = as.factor(Area)) %>% 
          filter(key %in% c("Temperature", "pH"))  %>% 
          nest(dataset = c(sample, value, std)) %>% 
          mutate(toStd = map(dataset, value2std),
                 toValue = map(dataset, std2value))

phylum.info <- read_csv(here("Input","higher_taxonomy.csv")) %>% 
  unite(family, genus, species, sep = "|", col = "taxa")


```
### Future scenarios for the Puget Sound

In order to project the suitability of the climate conditions in the Puget Sound and Salish Sea, we use the work from based upon Khangaonkar, T., Nugraha, A., Xu, W., & Balaguru, K. (2019). Salish Sea response to global climate change, sea level rise, and future nutrient loads. Journal of Geophysical Research: Oceans, 124. https://doi.org/10.1029/2018JC014670 and in particular, upon Figure 14 in that paper. Check the script Future_climate_conditions.R for further details.


```{r Future scenarios}
future.scenario <- tibble(Area = rep(c("Hood Canal", "SJI"), 6),
                  Year = rep(c(2017, 2091:2095), each = 2))  %>% 
  mutate(Temperature = map2(Area, Year, ~  r_Temperature_year(area = .x,year =  .y, 1000)),
         pH = map2(Area, Year, ~  r_pH_year(area = .x,year =  .y, 1000)))
future.scenario %>% unnest(cols = c(Temperature, pH)) -> future.scenario

# Make 2095 the 95% interval of the 2091-2095 scenarios 
future.scenario %>% 
  mutate(Year = case_when(Year == 2017 ~ 2017, 
                          TRUE        ~ 2095)) %>%
  group_by(Year, Area) %>% 
  nest() %>% 
  mutate(values = map (data, function (.x) {
                              list(temp = fitdistr(.x$Temperature ,
                                                 densfun = "normal"),
                                   ph = fitdistr(.x$pH ,
                                                 densfun = "normal")) 
            }),
         data = map2(data,values,  function (.x, .y){
                              .x %>%
                                mutate(pT = pnorm(Temperature, 
                                                  mean  = .y[["temp"]]$estimate[1],
                                                  sd = .y[["temp"]]$estimate[2]),
                                       ppH =pnorm(pH,
                                                  mean  = .y[["ph"]]$estimate[1], 
                                                  sd = .y[["ph"]]$estimate[2]) )
           })) %>% 
  
  unnest(data) %>% 
  
  mutate(keep = case_when(pT < 0.03 | ppH < 0.03 | pT > 0.98 | ppH > 0.98 ~ "Discard",
                          TRUE                   ~ "keep")) %>% 
  filter (keep == "keep") -> future.scenario

future.scenario %>% 
  select(-values) %>% write_csv(here("Output","simulation.from.std.functions.cleaned.csv"))
```

We are going to use this future simulation in two ways:

  * As it is, to explore the changes in suitability for each taxa between present and future sceanrios
  * As a means to establish a continuous grid of Temperature and pH, so we can visualize how broader changes might occur.

```{r create the grid}

future.scenario %>% 
  group_by(  Area) %>% 
  # filter (keep == "keep") %>%   
  summarise_at(c("Temperature", "pH"), list(max = max, min = min)) %>% 

  group_by ( Area) %>% 
  nest() %>% 
  mutate(data = map (data, ~ expand_grid(Temperature = seq(round(.x$Temperature_min,1), round(.x$Temperature_max, 1),by = 0.1),
                                         pH = seq(round(.x$pH_min,1), round(.x$pH_max,1), by = 0.1)))) %>% 
  unnest(data) -> full.grid
```

# Add the standardized values for each dataset

Because the standarization was done for each region separately, we have to convert them into standard values seapratedly as well.

```{r add standard values to both ds}

convertT <- function( values, area){
  stds_to_value %>% 
    filter (Area == area, key == "Temperature") %>% 
    pull(toStd) -> mod
    predict(mod[[1]],newdata = data.frame (value = values))
}
convertpH <- function( values, area){
  stds_to_value %>% 
    filter (Area == area, key == "pH") %>% 
    pull(toStd) -> mod
    predict(mod[[1]],newdata = data.frame (value = values))
}

full.grid %>% 
  rename(TemperatureCelsius = Temperature,
         pH_units           = pH) %>% 
  group_by(Area) %>% 
  nest() %>% 
  mutate(data =  map2(Area, data, ~ .y %>% 
                            mutate(Temp.std =convertT( area = .x, values =.y$TemperatureCelsius),
                                   pH.std   =convertpH(area = .x, values =.y$pH_units) ))) %>% 
  unnest(data) -> full.grid

future.scenario %>% 
  select(Area, Year, TemperatureCelsius = Temperature, pH_units = pH) %>% 
  group_by(Area) %>% 
  nest() %>% 
  mutate(data =  map2(Area, data, ~ .y %>% 
                            mutate(Temp.std =convertT( area = .x, values =.y$TemperatureCelsius),
                                   pH.std   =convertpH(area = .x, values =.y$pH_units) ))) %>% 
  unnest(data) -> future.scenario
```



### Save future scenarios

```{r}

full.grid %>%
  
write_rds( path  = here("Output","Temp.pH.grid.RDS"))

future.scenario %>% 
  write_rds(path = here("Output", "future.simulation.rds"))

future.scenario %>% 
  group_by( Area, Year) %>% 
  summarise_at(c("TemperatureCelsius", "pH_units"), .funs = list(min = min, max = max)) 

```

## Figure 1


We have the datasets and the map already made 

### Panel A Sample location
```{r Base map}
map <- readRDS(here("Input","map.plot.rds"))

map + ggtitle(label = element_blank()) + labs (x = "Longitude", y = "Latitude") -> map

```
### Panel B  Richness variation

```{r Species richness}

data.plankton %>% 
  left_join(phylum.info) %>% 
  group_by(event, phylum) %>% 
  summarise (Richness = n_distinct(taxa)) %>% 
  group_by(event) %>% 
  mutate(Total.Richness = sum(Richness)) %>% 
  separate(event, into = c("Site", "Date"), sep = "_") %>% 
  mutate(Area = case_when(Site %in% c("CP", "LK", "FH") ~ "San Juan Island",
                          TRUE                          ~ "Hood Canal"),
         Site = fct_relevel(Site, "CP", "LK", "FH","SA", "TR", "LL","PO", "TW")) -> data.for.richness 

data.for.richness %>%   
ggplot(aes(x = Site, y= Total.Richness )) +
  geom_boxplot(aes(fill = Area)) +
  lims (y= c(0,max(data.for.richness$Total.Richness))) +
  labs (y = "Species richness") -> left.rich.plot

data.for.richness %>% 
  filter (phylum %in% c("Bacillariophyta", "Dinophyceae")) %>% 
  ggplot(aes(x = Site, y= Richness )) +
  geom_boxplot(aes(fill = Area)) +
  facet_wrap(~phylum, nrow = 2, scales = "free_y") +
  labs (y = "") -> right.rich.plot

left.rich.plot + right.rich.plot + plot_layout(tag_level = "new") -> boxplot.richness
```


### Panel C Environmental variation

Make the ridges plot

```{r envRidges}
data.plankton %>% 
  select(sample = event, Area, TA = mean.TA, DIC = mean.DIC.new.sal,Salinity = Salinity.new ,Temperature, Omega.aragonite, pH = pH_new ) %>% 
  distinct() %>%  
  filter(pH > 7.4) %>% 
  ungroup() %>% 
  filter(!is.na(TA)) %>% 
  separate(sample, into= c("Site","Date"), remove = F, sep = "_" ) %>% 
  pivot_longer(cols = c(-Area, -Site, -Date,  -sample), names_to =   "Predictor", values_to  = "value")  %>% 
  mutate(Site = fct_relevel(Site, "SA", "TR", "LL","PO", "TW"),
         Predictor = fct_relevel(Predictor, "DIC", "TA", "pH")) %>% 
  mutate(Month = month(ymd(Date), label = T, abbr = F)) %>% 
  filter (Predictor %in% c("DIC", "TA", "pH", "Temperature", "Salinity")) %>% 
  ggplot(aes(x = `value`, y = `Month`, fill = Area)) +
  geom_density_ridges_gradient() +
 # scale_fill_viridis(name = "Temp. [F]", option = "C") +
  facet_wrap(~fct_relevel(Predictor, "DIC", "TA", "pH", "Temperature", "Salinity"), scales = "free", nrow = 1) +
  theme(legend.direction ="horizontal", axis.title.x = element_blank()) -> ridges

ridges + guides(fill = "none") -> ridges
```

### All together

THe top will be the environmental gradients, the lower panels will have the map and the boxplot. Create a custom palette of colors for the two regions


```{r assmbling Fig1}
Site.palette <- c("#d8b365", "#5ab4ac")

layout <- "
AAABBB
AAABBB
AAACCC
DDDDDD
DDDDDD"



wrap_plots(A = map ,
           B = boxplot.richness,
           C = guide_area(),
           D = ridges + labs(x = ""),
            design = layout,
            heights = c(10,10,1,10,10),
           guides = "collect")  +
  plot_annotation(tag_levels = c("A", "1"), tag_sep = ".")  & 
  theme_minimal() &
  theme(legend.direction = "horizontal",
        strip.background = element_rect(fill = "#2E3440"),
        strip.text = element_text(face = "bold", color = "#D8DEE9") ) &
  scale_fill_manual(values = Site.palette) -> Fig1 
  
Fig1
ggsave(Fig1, filename = here("Figures","Manuscript","Fig1.png"), width = 14, height = 12, dpi = "retina")

```

## Figure 2

To reuse for future analysis, create a function that does the fist step on a multivariate analysis: Create a horizontal matrix, a compatible matrix with the environmental data, and a dissimilarity object.

We start with a global dataset PERMANOVA, to show that the communities from each region are different to each other and require independent analyisis

```{r Global PERMANOVA}
data.plankton %>% 
  separate (event, into = c("Site", "Date"), sep = "_") %>% 
  mutate(Area = case_when(Site %in% c("CP","LK", "FH") ~ "San Juan Island",
                          TRUE                         ~ "Hood Canal")) %>% 
   unite (Site, Date, col = "event", sep = "_") %>% 
  mutate(GLOBAL = "Global") %>% 
  nest(-GLOBAL) %>% 
  mutate(comm.matrix = map (data, ~ tibble.to.table(.x, taxon = taxa, Abundance = Normalized.reads, sample.name = event)),
         bc = map(data, ~tibble_to_matrix(.x, taxon = taxa,Abundance = Normalized.reads, sample.name = event, distance = "bray",transformation = "" )),
         env = map (data, ~tibble_to_env(.x, taxon = taxa, Abundance = Normalized.reads, sample.name = event, everything()) %>% 
                       select(-contains("%")) %>% 
                       separate(event, into = c("Site", "Date"), sep = "_")),
         PERMANOVA = map2(bc, env, function(.x, .y){
           adonis(formula = .x ~ Area,data = .y, permutations = 9999
                    )
           
         })) %>% pull(PERMANOVA)
```


```{r functions for CAPS now without season}
cap.functions.only3things <- function(tibble, ...){ # ..  are the grouping factors
  
  tibble %>% 
    
    group_by(...) %>% 
    
    nest() %>% 
    
    mutate(comm.matrix = map (data, ~ tibble.to.table(.x, taxon = taxa, Abundance = Normalized.reads, sample.name = event)),
         
           ja = map(data, ~tibble_to_matrix(.x, taxon = taxa,Abundance = Normalized.reads, sample.name = event, distance = "jaccard",transformation = "binary" )),
          bc = map(data, ~tibble_to_matrix(.x, taxon = taxa,Abundance = Normalized.reads, sample.name = event, distance = "bray",transformation = "" )), # the bc distamce
          env = map (data, ~tibble_to_env(.x, taxon = taxa, Abundance = Normalized.reads, sample.name = event, everything()) %>% 
                       select(-contains("%")) %>% 
                       separate(event, into = c("Site", "Date"), sep = "_")))
}

```


We will do the Full CAP analysis - but will only keep Hood Canal for the MS - the rest will have to go to the Supplementary information

The figure will have three panels: the CAP for Hood Canal, the probability of presence of each cluster in the pH/Temperature space and the main contributors to the dissimilarity betweeen clusters.

```{r CAP analysis FULL}

data.plankton %>% 
  separate (event, into = c("Site", "Date"), sep = "_") %>% 
  mutate(Area = case_when(Site %in% c("CP","LK", "FH") ~ "San Juan Island",
                          TRUE                         ~ "Hood Canal")) %>% 
   unite (Site, Date, col = "event", sep = "_") %>% 
  cap.functions.only3things(Area) -> joined.dataset.for.CAP
```

Step by step. Create a column for each stage of the CAP analysis - and stop to check the signifficance of the CAP
```{r CAP1}
joined.dataset.for.CAP %>% 
  mutate(
    CAP.analysys.raw = map2(comm.matrix, env,
                          
                          function(.x,.y) {
                            .y %>% select (Temperature, Salinity = Salinity.new, pH = pH_new) 
                            caps <-  capscale(formula = .x ~ Temperature + Salinity + pH ,
                                                 data = .y %>%
                                                   select(DIC = mean.DIC.new.sal, Salinity = Salinity.new, Temperature, pH = pH_new) %>% 
                                                   select_if(is.numeric) %>%
                                                   decostand(method = "standardize", na.action = na.omit),
                                                 distance = "jaccard", 
                                                binary = T)
         
                            sppscores(caps) <- sqrt(decostand(.x, "total"))
                              
                            return(caps) }),
         CAP.plot = map (CAP.analysys.raw, ~ plot(.x)),
         
         CAP.significance = map(CAP.analysys.raw, ~ permutest(.x, permutations = 999 )) ) -> joined.dataset.for.CAP

joined.dataset.for.CAP %>% pull(CAP.significance)
```

Now we want to see if there are clusters associated with this. A first step is to choose how many clusters do we need to form. There are several methods for evaluating the goodness of fit of the number of clusters. 
So the best numbers of clusters are  

```{r CAP2}
joined.dataset.for.CAP %>% mutate(plot3 =  map2 ( CAP.plot, Area, function(.x, .y) {fviz_nbclust(.x$sites,
                                                                             kmeans,
                                                                             k.max = 5,
                                                                             method = "wss") + ggtitle(paste0 (.y, "-WSS"))})) %>% pull(plot3)

joined.dataset.for.CAP %>% mutate(plot3 =  map2 ( CAP.plot, Area, function(.x, .y) {fviz_nbclust(.x$sites,
                                                                             kmeans,
                                                                             k.max = 5,
                                                                             method = "gap_stat") + ggtitle(paste0 (.y, " gap_stat"))})) %>% pull(plot3)

joined.dataset.for.CAP %>% mutate(plot3 =  map2 ( CAP.plot, Area, function(.x, .y) {fviz_nbclust(.x$sites,
                                                                             kmeans,
                                                                             k.max = 5,
                                                                             method = "silhouette") + ggtitle(paste0 (.y, "-Silhouette"))})) %>% pull(plot3)
```

These three methods would not agree on a "perfect" number of clusters - but using 3 clusters for both areas returned good scores in all three criteria.

So using 3 clusters - generate these clusters and join the datasets

```{r CAP2b}
joined.dataset.for.CAP %>%
  ungroup %>% 
  mutate(n_clust = c(3,3), 
  

  CAP.clusters = map2 (CAP.plot,n_clust,  function (.x, .y) {

    final <- kmeans(.x$sites, .y, nstart = 15)

    fviz_cluster(final, data = .x$sites, geom = "point", palette = "Set2")

  } ),

  Cluster.df = map2 (CAP.plot,n_clust,  function (.x, .y) {

    final <- kmeans(.x$sites, .y, nstart = 15)

    tibble(event = names(final$cluster),
           cluster = final$cluster) }

    )
  ) -> Clusters.analysis.and.cap


Clusters.analysis.and.cap %>% 
  mutate(full.cluster.info = map2(env, Cluster.df, ~ .x %>% unite(Site, Date, col = "event") %>%right_join(.y) ),
         full.cluster.info = map2(full.cluster.info,CAP.plot, ~ .y$sites %>% 
                                    as.data.frame() %>% 
                                    rownames_to_column("event") %>% 
                                    right_join(.x) %>% 
                                    mutate(pH = round(pH,1)))

         ) -> Clusters.analysis.and.cap

# Write out clusers and CAP points, and raw env data

Clusters.analysis.and.cap %>% 
  select(Area,  full.cluster.info) %>% 
  unnest() %>%
  write_csv(here("Output","clusters.of.events.csv"))

```

Now create the plot that combines Constrained Analysis of Principal Coordinates and clusterings
### Panel A: CAP analysis with environmnental correlation and cluster info

```{r Hand made CAP}



Clusters.analysis.and.cap %>% 
 
  mutate(Hand.made.CAP = map2(CAP.plot, full.cluster.info, function (.x, .y){
    
    
    .x$biplot %>%
                         as.data.frame() %>%
                        rownames_to_column("env.variable") -> var.scores
   
    .y %>% 
      select(event, CAP1, CAP2, cluster) %>% 
      ggplot(aes(x = CAP1,
                 y = CAP2)) +
      ggforce::geom_mark_hull(aes( group= cluster, color = as.factor(cluster),label = as.factor(cluster), fill = as.factor(cluster)),
                          expand = unit(2, "mm"),
                 label.margin = margin(1, 1, 1, 1, "mm"),
                 label.buffer = unit(0, "mm"),
                 con.cap = 1 ,
                 alpha = 0.5) +
     
      geom_point(size = 1.5) +
       geom_point(aes(color = as.factor(cluster)), size = 1) +
      geom_segment(aes(x = 0, y = 0,
                       xend = CAP1,
                       yend = CAP2), data = var.scores, color = "blue", arrow = arrow(length = unit(0.1,"cm"))) +
      geom_label_repel(aes(x= CAP1  ,
                           y= CAP2 ,
                           label = env.variable), data = var.scores, fill = "pink", alpha = 0.75) +
      ggtitle ("") + coord_equal() + scale_color_brewer(name = "Cluster", palette = "Set2") + scale_fill_brewer(name = "Cluster",palette = "Set2") +

      theme(legend.position = "bottom")
      

  })) %>% pull(Hand.made.CAP) -> leftplot.Fig2


 leftplot.Fig2 %>% set_names(Clusters.analysis.and.cap$Area) %>% map(~ .x +  theme_light() + theme(legend.position = "none") ) -> left_top

```

### Panel B: Cluster prevalence in the Temperature / pH space

We need the simulated data of the future conditions, and the cluster information.

```{r}


clusters <- read.csv(here("Output","clusters.of.events.csv")) %>% 
  mutate(cluster  = as.factor(cluster)) %>% 
  nest(clusterdata = -Area)
```

Use a multinomial model to predict the cluster identity as a function of Temperature and pH.

```{r models and so for getting the communities}
clusters %>% 
  mutate (multi.mod = map (clusterdata, ~ multinom(cluster ~ Temperature + pH_new, data = .x))) -> clusters

```

Now create the prediction of the most likely community under each Temp-pH combination.

```{r models and so for getting the communities2}

full.grid %>% 
  mutate (Area = str_replace(Area, replacement = "San Juan Island", pattern =  "SJI")) %>%
  rename(Temperature = TemperatureCelsius,
         pH_new = pH_units) %>% 
    group_by(Area) %>% 
    nest() %>% 
    left_join(clusters) %>% 
    mutate(whichComm.res = map2(data,multi.mod,~ .x %>% 
                                  mutate(comm = as.numeric (apply(predict(.y, type = "probs", newdata = .x),1, which.max)) )
              ) ,
           plots = map(whichComm.res, ~ 
                         ggplot(.x, aes(y = pH_new,
                                        x = Temperature,
                                        fill = as.factor(comm),
                                        )) +
                         geom_tile()+
                         geom_label(data = . %>% group_by(comm) %>% 
                                      summarise_all( mean),
                                    aes(x= Temperature,
                                        y= pH_new,
                                        label = comm),
                                    fill = "white")+
                         scale_fill_brewer(name = "Cluster", palette = "Set2") +
                         xlab("Temperature") + ylab("pH")+
                         theme_light())) -> testquick
  
testquick %>% pull(plots) %>% set_names(testquick$Area) %>% map(~ .x +  theme(axis.title.y = element_text(angle = 0),legend.position = "none") )-> center_top
```

### Panel C: For each cluster, follow the relative abundance of the taxa driving the differences

#### Generate the SIMPER clusters
```{r}
Clusters.analysis.and.cap %>% 
  mutate(SIMPER.clusters = map2(comm.matrix, Cluster.df, function(.x, .y) {
    
    simper(comm = .x,
          group = as.factor(.y$cluster),
          permutations = 999)
    
  })) %>% 
  select(Area, SIMPER.clusters) -> SIMPER.clusters 

SIMPER.clusters %>% 
  mutate(summary.simper = map(SIMPER.clusters, ~ summary(.x, ordered  = TRUE) )) %>% 
  mutate(taxa.simper = map(summary.simper, ~ map(.,function(x) rownames_to_column(x, var = "taxa") %>% pull(var = taxa)   )[[1]])) -> SIMPER.clusters


## Get the data for all  areas
 SIMPER.clusters %>%
   pull(summary.simper)-> list.of.simpers
names(list.of.simpers) <- SIMPER.clusters$Area

 list.of.simpers %>%
  map(~ .x %>% map(~ bind_rows(.)) %>% 
                          bind_rows(., .id = "Comparison")) %>% 
  bind_rows(., .id = "var1") %>%
   separate(var1, into = c("Area", "Season"), sep = "_") %>%
   select(-Season) %>% 
   group_by(Area,  Comparison) %>% 
   nest() %>% 
   left_join(SIMPER.clusters) %>%
   mutate(data = map2(data, taxa.simper, ~bind_cols(.x, as_tibble(.y)))) %>% 
   select(Area,  Comparison, data) %>% 
   unnest(data) %>% 
  # rename(taxa = value) %>% 
  write_csv(here("Output","simper.all.csv") )
   

  
```
#### Now do the topright
 get the data and plt a distribution of the average contributions of each taxa for each 
```{r}
taxa.to.follow <- read_csv(here("Output","simper.all.csv")) 
 

taxa.to.follow %>% 
  ggplot(aes(x = average)) + 
  geom_histogram() +
  facet_grid(Area ~ Comparison)
```


### Choose a threshold of 0.01 for average contribution

And keep some that are more abundant on each cluster too

```{r}
taxa.to.follow %>% 
  filter (average > 0.01) %>%  
  arrange(desc(average)) %>% 
  group_by(Area, Comparison, ava > avb) %>% 
    slice(1:5) %>% 
  
  transmute(Area, Comparison, taxa = value, diff = avb - ava, average = case_when(ava > avb ~ average, TRUE ~ -average), sd) %>% 
  left_join(phylum.info %>% select(phylum,taxa)) %>% 
  separate(taxa, into = c("family","genus", "species"), sep = "\\|", remove = F) %>%
  mutate(label = case_when((species == "NA" & genus == "NA") ~ paste0(family, " sp."),
                           species == "NA" ~  paste0(genus, " sp."),
                           TRUE            ~ species)) %>%
  mutate(label2 = paste(phylum, label, sep = " | ")) %>% 
  mutate(Comparison = fct_relabel(Comparison, ~ str_replace(.,"_", " vs "))) %>% 
  nest(-Area) %>% 
  mutate(plot = map(data, function(.x){
    lims = c(-max(abs(.x$average) + (.x$sd)), max(abs(.x$average) + (.x$sd)))
    ggplot(.x, aes(y = average,
             x = fct_reorder(label2, phylum))) +
  geom_col(aes(fill = diff>0), size = 0.5, color = "black") +
      geom_errorbar(aes(ymin = average -sd, ymax = average + sd ), width = 0.25) +
  geom_hline(yintercept = 0, color = "black")+
  labs (x = "taxa",
        y = "Contribution to dissimilarity")+
  coord_flip(ylim=lims) +
    scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
  facet_wrap(~Comparison) +
  guides(fill = "none") +
    
 
    theme_light() + theme(axis.text.y = element_text(face = "bold.italic", colour ="#3B4252", hjust = 0 ),
                          strip.background = element_rect(fill = "#2E3440"),
        strip.text = element_text(face = "bold", color = "#D8DEE9")
        # strip.background = element_rect(fill = "#3B4252"),
        # strip.text = element_text(face = "bold", color = "#EBCB8B")
        )} 
  ))   -> right_most
  
right_most %>% pull(plot) %>% set_names(right_most$Area) -> right_top
right_top
```


### Final Figure 2

Here is the code for the figure that goes in the MS - the San Juan Island's is on the next chunk of code.

```{r assembling Figure 2}



left_top[["Hood Canal"]] + theme(legend.position  = "right", 
                                 axis.title.y = element_text(vjust = 0.5, angle = 0))  -> p1
 center_top[["Hood Canal"]] + theme(axis.title.y = element_text(vjust = 0.5, angle = 0)) -> p2
 right_top[["Hood Canal"]] +  theme(axis.title.y = element_blank())-> p3

layout5 <-c(
  patchwork::area(t= 1, l=1 , b=6 , r=4),
  patchwork::area(t= 7, l=1 , b=11 , r=4),
 # area(t= 5, b=5, l=4),
  patchwork::area(t= 1, l= 6, b= 11, r=9)
) 

plot(layout5)
p1 + 
  p2 +
  # guide_area()+ 
  p3 + plot_layout(design = layout5) + plot_annotation(tag_levels = "A")  -> plot


ggsave(plot,filename = here("Figures","Manuscript",paste0("Figure2.", Sys.Date(), ".png")),
         width = 14,height = 11, dpi = "retina") 

```

```{r assembling Figure for Supplementary material}

left_top[["San Juan Island"]] + theme(legend.position  = "right")  -> p1
 center_top[["San Juan Island"]] -> p2
 right_top[["San Juan Island"]] -> p3
p1 + 
  p2 +

  p3 + plot_layout(design = layout5) + plot_annotation(tag_levels = "A")  -> plot

ggsave(plot,filename = here("Figures","Supplementary",paste0("Supp.info.San.Juan.Island.Fig2", Sys.Date(), ".png")),
         width = 14,height = 11, dpi = "retina") 

```


## Figure 3: a quick glance at spp responses
Get the models output and calculate the posterior across the simulated scenario

Now, calculate the posterior of each taxa across the 16,276 scenarios simulated

### Posterior per taxa per point in the future

We use the climate projection to predict changes in suitability. First panel is a visualization of the suitability of planktonic taxa, highlighting those species with a more pronounced change.

```{r Prepare dataset}
models$data %>% 
  distinct(Area, taxa, taxonAreaIndex) -> keepers 

expanded.future <- future.scenario %>% 
  select(Area, Year, Temperature = Temp.std, TemperatureCelsius, pH = pH.std, pH_units) 

## Get 

expand_grid(models$data %>% distinct(taxa), expanded.future) -> expanded.future

left_join(expanded.future, keepers) -> expanded.future
```


```{r Calculate the 100 draws}
posterior_predict(object = models,
                   newdata = expanded.future,
                   draws = 100) -> posterior.predict.all.taxa 

# This is an object with as many rows as environmental points there are. The first two columns are taxa and nrow. The rest are the binary output of the posterior
# predict

expanded.future %>% left_join(phylum.info) -> expanded.future 

expanded.future$present <- colMeans(posterior.predict.all.taxa)

```

Now choose for each phyla, the taxa with more dramatic change

```{r choose taxa with more change}
expanded.future %>% 
  left_join(phylum.info) %>% 
  nest(-phylum) %>% 
  mutate(suma = map (data,~.x %>% group_by(taxa,Area, Year) %>%
                       summarise(prop = mean(present)) %>%
                       ungroup() %>% 
                       pivot_wider(names_from = Year, values_from = prop) %>% 
                        group_by(taxa) %>% mutate(diff = `2017` - `2095`) %>% 
                       pivot_wider(names_from = Area, values_from = c(`2017`, `2095`, diff)) %>% 
                       mutate(sum = sum(abs(`diff_Hood Canal`), abs(diff_SJI)))
                     )) %>% 
  select(phylum, suma) %>% 
  unnest(suma) %>% 
  group_by(phylum) %>% arrange(desc(sum)) %>% 
  separate(taxa, into = c("family","genus", "species"), sep = "\\|", remove = F) %>%
  mutate(label = case_when((species == "NA" & genus == "NA") ~ paste0(family, " sp."),
                           species == "NA" ~  paste0(genus, " sp."),
                           TRUE            ~ species)) -> taxa.and.diff



taxa.and.diff %>% 
  filter(str_detect(label, paste(c("Centropages", "Nitzschia lo", "Nitzschia pro","Prorocentrum", "Emili", "Alexandrium", "Chaetoceros soc","Stephanodiscus","Coscinodiscus", "Karlodi",
                                   #"Navicula cry","Navicula gla",
                                   "Chryso", "Bathy", "Gym", "Li"), collapse = "|"))) %>% select(taxa, label)-> second.sel
  

```

```{r Fig3left}

expanded.future %>% 
  separate(taxa, into = c("family","genus", "species"), sep = "\\|", remove = F) %>%
  mutate(label = case_when((species == "NA" & genus == "NA") ~ paste0(family, " sp."),
                           species == "NA" ~  paste0(genus, " sp."),
                           TRUE            ~ species))    %>%
  mutate(Area = as.character(Area)) %>%
  mutate(Area = case_when(Area == "SJI" ~ "San Juan Island",
                          TRUE          ~ Area)) %>%
  mutate(Year = fct_rev(as.factor(Year) )) -> input.for.left

input.for.left %>%
   group_by(phylum, Temperature, pH, Year, Area ) %>%
  summarise(present = sum(present)) %>%
  group_by(phylum,Area) %>% 
  mutate(present = present/max(present)) %>% 
  mutate (label = phylum) -> phylum.stats

phylum.stats %>% 
  nest(-phylum) %>% 
  mutate( plot.by.phyl = map2 (data, phylum, ~ .x %>%
  ggplot(aes()) +
  scale_fill_brewer(name = "Year",  type = "qual", palette = 4, direction = 1,
                    breaks=c("2017","2095")) +
  labs (x = "Phylum-wide standardized richness",
        y = "") +
  facet_wrap(~Area) +
  theme_minimal() +
  theme (strip.text.y = element_text(angle = 0),
        axis.text.y = element_text(face = "italic"), 
        #plot.background   = element_rect(fill = "#E5E9F0"),
        legend.direction = "horizontal",
        legend.position  = "bottom",
        plot.title.position = "plot",
        plot.title = element_text(face = "bold",vjust =  -5 ),
        axis.title.x.top  = element_text(face = "bold",vjust = 3) ) +
        geom_histogram(aes( x= present,after_stat(ncount),
                            fill = as.factor(Year),
                            group= as.factor(Year)),
                       binwidth = 0.025,
                       colour = "black",
                       position = "identity", 
                       alpha = 0.75) +
        scale_x_continuous(position = "top", limits = c(0,1)))) %>% 
  select(-data)-> summary.plot



input.for.left %>% 
  semi_join(second.sel, by = "taxa") %>%
  nest(-phylum) %>% 
  mutate( plot.by.taxa = map2 (data, phylum, ~ .x %>%
                                 ggplot(aes(x= present,
                                           y = label)) +
                                 scale_fill_brewer(name = "Year",  type = "qual", palette = 4, direction = 1,
                                                   breaks=c("2017","2095")) +
                                 labs (x = "Probability of presence",
                                       y = "") +
                                 facet_wrap(~Area) +
                                 theme_minimal() +
                                 theme(strip.text.y = element_text(angle = 0),
                                       axis.text.y = element_text(face = "italic"),
                                       legend.direction = "horizontal",
                                       legend.position  = "bottom",
                                       plot.title.position = "plot",
                                       plot.title = element_text(face = "bold",vjust =  -5 ),
                                       axis.title.x.top  = element_text(face = "bold",vjust = 3) ) +
                                 ggtitle(.y)  +
                                 geom_boxplot(aes(fill = as.factor(Year)), outlier.alpha = 0.5) +
                                 scale_x_continuous(position = "top") )) -> fig3.left

fig3.left %>%  right_join(summary.plot) -> left.plot.all
left.plot.all %>% pull(plot.by.phyl) %>% set_names(nm = left.plot.all$phylum) -> left.plot.top
left.plot.all %>% pull(plot.by.taxa) %>% set_names(nm = left.plot.all$phylum) -> left.plot

```

### Richness by phyla with time
 First prepare the grid - expand it to include the taxa
```{r}
full.grid %>% 
  select(Area,  Temperature = Temp.std, TemperatureCelsius, pH = pH.std, pH_units) -> full.grid

expand_grid(models$data %>% distinct(taxa), full.grid) -> full.grid

left_join(full.grid, keepers) -> full.grid
```

Now calculate the posterior from each point in the grid
```{r}
posterior_predict(object = models,
                   newdata = full.grid,
                   draws = 100) -> posterior.predict.all.taxa
 
```

Add the phylum information and calculate the richness at each point
```{r}
full.grid %>% left_join(phylum.info) -> full.grid 

full.grid$present <- colMeans(posterior.predict.all.taxa)

full.grid$sd <- apply(posterior.predict.all.taxa,2,sd )

full.grid %>% 
  group_by(Area, Temperature = TemperatureCelsius, pH = pH_units, phylum) %>% 
  summarise(richness = sum(present)) %>% 
#  left_join(richness.by.phylum) %>% 
  group_by(phylum) %>% 
  mutate(st.richness = richness/max(richness)) -> richness.by.phylum
```


```{r plot4 function}
plot4 <- function(tibble, response) {
  
  response = enquo(response)
  
  
  tibble %>% 
    ungroup() %>% 
    mutate(Area = as.character(Area)) %>% 
    mutate(Area = case_when(Area == "SJI" ~ "San Juan Island",
                            TRUE          ~ Area)) %>% 
    mutate(Temperature = round(Temperature, 1),
           pH = round(pH, 1)) %>% 
    group_by(Temperature, pH, Area) %>%

    summarise (!!response := mean (!!response))  %>%
  
    ggplot(aes(x = Temperature,
             y = pH) ) +
  
  geom_raster( interpolate = T,aes( fill = !!response)) +
  
  scale_fill_distiller(name = "Standarized Richness", type = "seq", palette = "Spectral",limits=c(0,1) ) +

  scale_color_brewer(name = "Year",  type = "qual", palette = 4, direction = -1, breaks=c("2017","2095")) +
  ggforce::geom_mark_hull(data = future.scenario %>%
                            ungroup() %>%
                            mutate(Area = as.character(Area)) %>% 
                            mutate(Area = case_when(Area == "SJI" ~ "San Juan Island",
                            TRUE          ~ Area)) %>%
                            filter (Year %in% c(2017, 2095)) ,
                          aes(x= TemperatureCelsius, y = pH_units, group= Year, color = as.factor(Year),label = as.factor(Year)),
                          expand = unit(0.5, "mm"),
                 label.margin = margin(1, 1, 1, 1, "mm"),
                 label.buffer = unit(0, "mm"),
                 con.cap = 0 ,
                 alpha = 0.5) +
     facet_grid(.~Area, scales = "free_x",space = "free_x") +
  guides(color = "none") +
    labs (x = "Temperature",
          y= "pH") +
    theme_minimal()+
    theme(legend.position = "bottom",
          legend.key.width  = unit(2 ,"cm"),
          axis.title.x = element_text(face = "bold"),
          legend.direction = "horizontal") +
    scale_x_continuous(position = "top")
}
```


```{r plot4 in play}
richness.by.phylum %>% 
  nest(-phylum) %>% 
  mutate(plot = map(data, ~ plot4(.x, response = st.richness)))  -> list.of.richness.plots



list.of.richness.plots %>%  pull(phylum) -> list.of.phyla


list.of.richness.plots %>% pull(plot) -> fig3.right

fig3.right <- set_names(fig3.right, nm = list.of.phyla)


```

### Assembling Figure 3

Following reviewer's suggestions, we are limiting the information displayed in the main Figures to two of most important phyla for coastal ecosystems dinamics: Diatoms and Dinoflagellates.
```{r}
layout <- "
AA
BB
##
CC
DD
##
EE
GG
HH
"
wrap_plots(A = left.plot[["Dinophyceae"]] + labs(title = "A.1", tag = "Dinophyceae") ,
           B = left.plot.top[["Dinophyceae"]] + guides(fill = "none")+ labs(title  ="A.2"),
          # F = plot_spacer(),
           C = left.plot[["Bacillariophyta"]] + labs(title ="B.1", tag = "Bacillariophyta"),
           D = left.plot.top[["Bacillariophyta"]] + guides(fill = "none")+ labs(title ="B.2"),
           E = left.plot[["Haptophyceae"]] + labs(title ="C.1", tag = "Haptophyceae"),
           G = left.plot.top[["Haptophyceae"]] + guides(fill = "none")+ labs(title  ="C.2"),
           H = guide_area(), design = layout, heights = c(3,2,1,3,2,1,3,2,1), guides = "collect") &
  theme(plot.tag.position = c(0.1,1),
        plot.tag = element_text(face = "bold")) -> left

layout2 <- "
AA
AA
##
CC
CC
##
EE
EE
HH
"
wrap_plots(A = fig3.right[["Dinophyceae"]] + labs(title  ="A.3"),
          # F = plot_spacer(),
           C = fig3.right[["Bacillariophyta"]] + labs(title ="B.3"),
           E = fig3.right[["Haptophyceae"]]+ labs(title ="C.3"),
           H = guide_area(), design = layout2, heights = c(3,2,1,3,2,1,3,2,1), guides = "collect")&
  theme(plot.tag.position = c(0.1,1),
        plot.title  = element_text(face = "bold")) -> right

(left|right)+plot_layout(widths = c(2,2))  -> plot 
   ggsave(plot , filename = here("Figures","Manuscript", paste0("Top_fig3_",Sys.Date(),".Other.sel.png")), units = "in", dpi = "retina", width = 20, height = 14)
 
```

#### Bonus track:Create phylum-specfic plots for Supplementary Information


```{r}
input.for.left %>% 
  nest(-phylum) %>% 
  mutate( plot.by.taxa = map2 (data, phylum, ~ .x %>%
                                 ggplot(aes(x= present,
                                           y = label)) +
                                 scale_fill_brewer(name = "Year",  type = "qual", palette = 4, direction = 1,
                                                   breaks=c("2017","2095")) +
                                 labs (x = "Probability of presence",
                                       y = "") +
                                 facet_wrap(~Area) +
                                 theme_minimal() +
                                 theme(strip.text.y = element_text(angle = 0),
                                       axis.text.y = element_text(face = "italic"),
                                       legend.direction = "horizontal",
                                       legend.position  = "bottom",
                                       plot.title.position = "plot",
                                       plot.title = element_text(face = "bold",vjust =  -5 ),
                                       axis.title.x.top  = element_text(face = "bold",vjust = 3) ) +
                                 ggtitle(.y)  +
                                 geom_boxplot(aes(fill = as.factor(Year)), outlier.alpha = 0.5) +
                                 scale_x_continuous(position = "top") )) -> fig3.left

fig3.left %>% 
  left_join(list.of.richness.plots, by = "phylum") -> fig3.left

fig3.left %>% pull(plot) %>% set_names(fig3.left$phylum) -> rights
fig3.left %>% pull(plot.by.taxa) %>% set_names(fig3.left$phylum) -> lefts

map2(lefts, rights, 
     function(.x,.y){
       
       .x  + plot_spacer()+ .y + plot_layout(widths = c(4,1,4)) 
       
     }) -> Suppl.Material.plots.final

paths <- paste0("Supp.fig.",names(lefts),".png")

pmap(.l = list(Suppl.Material.plots.final, paths),
     .f = function(a,b) a + ggsave(plot = a,
                               filename = here("Figures","Supplementary", b),
                                    device = "png",
                                    units = "in",
                                    dpi = "retina",
                                    width = 20,
                                    height = 12))

```

#### Bonus track 2: changes in richness, tested

First calculate the richness in each point as following. In each environmental point, the 100 draws represent if a taxa was found or not. We sum the draws of all taxa so we have 100 estimation of richness for each point - we then take the mean of those 100 draws and we have a estimation of richness at that point.

```{r get the richness per phylum}

split.matrices.by.taxa <- list()

for (i in 1:n_distinct(expanded.future$taxa)){
  start.col = 1 + (i-1)*10873
  fin.col = start.col + 10872

  split.matrices.by.taxa[[i]] <- posterior.predict.all.taxa[,start.col:fin.col]
  }

richness.fun <- function(x) {
    Reduce('+', x) 
    }

distinct(expanded.future,taxa) %>% 
  mutate(draws = split.matrices.by.taxa) %>% 
  left_join(phylum.info %>% select(taxa, phylum)) %>% 
  group_by(phylum) %>% 
  summarise(draws =  Reduce('+',draws)) -> richness.by.draw.by.phylum.by.point


 richness.by.draw.by.phylum.by.point %>% 
   nest() %>% 
   mutate(data = map (data, function(.x) colMeans(as.matrix(.x)) %>% 
                        as_tibble %>% 
                        rownames_to_column("sim.row"))) %>% 
   unnest()-> richness.by.phylum.by.point
 
 expanded.future %>%
   ungroup() %>% 
   slice (1:10873) %>% 
   rownames_to_column("sim.row") %>% 
   select(Area, Year, sim.row) %>% 
   right_join(richness.by.phylum.by.point) -> richness.by.phylum.by.point

  
```

Now the Global - richness by point

```{r}
# distinct(expanded.future,taxa) %>% 
#   mutate(draws = split.matrices.by.taxa) %>% 
#   summarise(draws =  Reduce('+',draws)) -> richness.by.draw.by.point
# 
# richness.by.draw.by.point %>% 
#    nest() %>% 
#    mutate(data = map (data, function(.x) colMeans(as.matrix(.x)) %>% 
#                         as_tibble %>% 
#                         rownames_to_column("sim.row"))) %>% 
#    unnest()-> richness.by.point

#overall change in richness
expanded.future %>% 
  group_by(Year, Temperature, pH, Area) %>% 
  summarise(richness = sum(present)) %>% 
  group_by(Year, Area) %>% 
  summarise(median(richness))
#diatom change in richness
expanded.future %>% 
  filter(phylum == "Bacillariophyta") %>% 
  group_by(Year, Temperature, pH, Area) %>% 
  summarise(richness = sum(present)) %>% 
  group_by(Year, Area) %>% 
  summarise(median(richness))


expanded.future %>%
   ungroup() %>% 
   slice (1:10873) %>% 
   rownames_to_column("sim.row") %>% 
   select(Area, Year, sim.row) %>% 
   right_join(richness.by.point) -> richness.by.point
```

Because we are comparing two 
```{r}

## GLOBAL TEST

richness.by.point %>% 
  nest(-Area) %>% 
  mutate(wilcoxon = map(data, ~ wilcox.test(value ~ Year, data = .x)),
         tidy_wilcox = map(wilcoxon, broom::tidy)) %>%
  pull(wilcoxon) 

## We cannot  

richness.by.phylum.by.point %>% 
   nest(-phylum,-Area) %>% 
   mutate(wilcoxon = map (data, ~ wilcox.test(value ~ Year, data = .x) ))  -> results.lm
   

results.lm %>%  filter (phylum == "Bacillariophyta") %>% pull(wilcoxon) 
```