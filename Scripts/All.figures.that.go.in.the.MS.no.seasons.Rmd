---
title: "Analysis and Figures for Gallego et al, 2020"
author: "Ramon Gallego"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F)
```

## Intro

This Markdown will make the part of the analysis that goes in the Manuscript: 

```{r libraries and custom functions, echo = F, message=F}
library (RColorBrewer)
library (patchwork)
library (rstanarm)
library (fitdistrplus)
library (ggridges)
library (ggforce)
library (tidyverse)
library (cowplot)
library (concaveman)
library (vegan)
library (lubridate)
library (ggrepel)
library (factoextra)
library (nnet)
library (here)
library (conflicted)
conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")
conflict_prefer("area", "patchwork")
#functions for future Salish Sea
models <- readRDS(here("Input","full_model_output_rpk_TpH.standardized_nonSeasonal2020-06-24_3262.RDS"))

source(here("Scripts","Future_climate_conditions.R"))


source(here("Scripts","tibble.to.matrix.r"))

stds_to_value <- read_rds(here("Input", "std_to_real.rds"))


```

## Datasets to use

To begin with: the ASV.by.taxa dataset and the environmental data (Updated salinity, DIC and pH). 

### Present day datasets

```{r }
data.plankton <- read_csv(here("Input","Combined_Biol_Env_Plankton.csv"))

data.plankton %>% filter(!str_detect(taxa, "Phasianidae|Laridae")) %>% 
  filter (!str_detect(taxa, "Rhodomelaceae")) -> data.plankton

env.data <- read_csv(here("Input","env.data.for.log.regression.csv"))

#quality-control data
    env.data %>%
      filter(pH > 7) %>%
      mutate(
        Season = case_when(
          str_detect(sample, "1703|1710|1711|1801|1803") ~ "Winter",
          TRUE ~ "Summer"
        ),
        Area = case_when(
          str_detect(sample, "CP|LK|FH") ~ "SJI",
          TRUE ~ "Hood Canal"
        )
      ) -> now.env.data

now.env.data %>%
  gather(-Season, -sample, -Area,  key = "Predictor", value = "value") %>%
  group_by(Area, Predictor) %>%   #RPK: this was missing, which messed up the std calculations 
  mutate(std = vegan::decostand(value, method = "standardize")) -> now.env.data.with.std

#### TODO: remove

# Dataset to go between standarized and real values
now.env.data.with.std %>%
  group_by(Area, Predictor) %>%
  # summarise(mean = mean(value),
  #           sd = sd(value)) %>%
  # group_by(Area, Predictor) %>%
  nest() %>% 
  summarise(tovalue = map(data, ~ lm(value ~ std, data = .x) ),
            tostd   = map(data, ~ lm(std ~ value, data = .x)))-> transforming.df 

transforming.df[1,4] %>% pull -> test
broom::tidy(test[[1]])
extract <- function (lm) {broom::tidy(lm)$estimate}

extract(test[[1]])

transforming.df %>% 
  mutate(to.values = map(tovalue, extract),
         to.std= map(tostd, extract)) ->transforming.df

phylum.info <- read_csv(here("Input","higher_taxonomy.csv")) %>% 
  unite(family, genus, species, sep = "|", col = "taxa")

```
### Future scenarios for the Puget Sound

In order to project the suitability of the climate conditions in the Puget Sound and Salish Sea, we use the work from based upon Khangaonkar, T., Nugraha, A., Xu, W., & Balaguru, K. (2019). Salish Sea response to global climate change, sea level rise, and future nutrient loads. Journal of Geophysical Research: Oceans, 124. https://doi.org/10.1029/2018JC014670 and in particular, upon Figure 14 in that paper. Check the script Future_climate_conditions.R for further details.


```{r Future scenarios}
Year.area.dataset <- function(Area, Year, n){
            
    Temp.conv <- stds_to_value[which (stds_to_value$Area == Area & stds_to_value$key == "Temperature"),"toValue"] %>% pull %>% .[[1]]
    pH.conv   <- stds_to_value[which (stds_to_value$Area == Area & stds_to_value$key == "pH")         ,"toValue"] %>% pull %>% .[[1]]
           
    one<-  data.frame(
              Area = Area,
              Year = Year,
              Temperature = r_Temperature_year_STD(Year, Area, n, 2017),
              pH          = r_pH_year_STD(Year, Area, n, 2017)
              ) 
    
    one$TemperatureCelsius = sapply(one$Temperature,function(x){Temp.conv$coefficients[1]+Temp.conv$coefficients[2]*x})
    one$pH_units            = sapply(one$pH,function(x){pH.conv$coefficients[1]+pH.conv$coefficients[2]*x})  
    
    return(one)
            
}



j <- Year.area.dataset("Hood Canal", 2095, 5000)
k <- Year.area.dataset("Hood Canal", 2017, 5000)
l <- Year.area.dataset("SJI", 2095, 5000)
m <- Year.area.dataset("SJI", 2017, 5000)


simulated.scenario <- rbind(j,k,l,m)

rm(j,k,l,m)

simulated.scenario %>%
  group_by(Year, Area) %>% 
  nest() %>% 
  mutate(
    values = map (data, function (.x) {
      list(temp = fitdistr(.x$TemperatureCelsius ,
             densfun = "normal"),
           ph = fitdistr(.x$pH_units ,
             densfun = "normal"))
            }
          ),

    data = map2(data,values,  function (.x, .y){
      .x %>%
        mutate(pT = pnorm(TemperatureCelsius, mean  = .y[["temp"]]$estimate[1], sd = .y[["temp"]]$estimate[2]),
               ppH =pnorm(pH_units, mean  = .y[["ph"]]$estimate[1], sd = .y[["ph"]]$estimate[2]) )
      })
    ) %>% 
  unnest(data) %>% 
  mutate(keep = case_when(pT < 0.05 | ppH < 0.05 | pT > 0.95 | ppH > 0.95 ~ "Discard",
                          TRUE                   ~ "keep")) %>% 
  filter (keep == "keep")-> simData.nocrazys

simData.nocrazys %>% 
  select(-values) %>% write_csv(here("Output","simulation.from.std.functions.cleaned.csv"))
```

### Save future scenarios

```{r}

simData.nocrazys %>%
  
saveRDS( file = here("Output","all.sim.data_climateScenarios_no.outliers.RDS"))

simData.nocrazys %>% 
  group_by( Area, Year) %>% 
  summarise_at(c("TemperatureCelsius", "pH_units"), .funs = list(min = min, max = max)) 

```

## Figure 1


We have the datasets and some plots already made - 

### Panel A Sample location
```{r Base map}
map <- readRDS(here("Input","map.plot.rds"))

map + ggtitle(label = element_blank()) + labs (x = "Longitude", y = "Latitude") -> map

```
### Panel B Environmental variation

Make the ridges plot

```{r}
now.env.data %>% 
  select(TA = mean.TA, DIC = mean.DIC, everything(), -contains("%")) %>% 
  filter(!is.na(TA)) %>% 
  separate(sample, into= c("Site","Date"), remove = F )-> env.data.no.outliers

env.data.no.outliers %>% 
  pivot_longer(cols = c(-Area, -Site, -Date, -Season, -sample), names_to =   "Predictor", values_to  = "value") -> env.data.to.keep

env.data.to.keep %>% 
  mutate(Site = fct_relevel(Site, "SA", "TR", "LL","PO", "TW"),
         Predictor = fct_relevel(Predictor, "DIC", "TA", "pH")) -> env.data.to.keep 


env.data.to.keep %>% 
  mutate(Area = case_when (Area == "SJI" ~ "San Juan Island",
                           TRUE          ~ Area)) %>% 
  mutate(Month = month(ymd(paste0(Date, "01")), label = T, abbr = F)) %>% 
  filter (Predictor %in% c("DIC", "TA", "pH", "Temperature", "Salinity")) %>% 
  ggplot(aes(x = `value`, y = `Month`, fill = Area)) +
  geom_density_ridges_gradient() +
 # scale_fill_viridis(name = "Temp. [F]", option = "C") +
  facet_wrap(~fct_relevel(Predictor, "DIC", "TA", "pH", "Temperature", "Salinity"), scales = "free", nrow = 1) +
  theme(legend.direction ="horizontal") -> ridges

legend <- get_legend(
  # create some space to the left of the legend
  ridges + theme(legend.box.margin = margin(0, 0, 0, 12))
)
 legend
ridges + guides(fill = "none") -> ridges
```

### Panel c: Richness variation

```{r}
boxplot.richness <- readRDS(here("Input","richness.rds"))

boxplot.richness +
  ylim (0,60) -> boxplot.richness
```
### All together

THe top will be the environmental gradients, the lower panels will have the map and the boxplot
```{r}
plot_grid(plotlist = list(map, legend, boxplot.richness),
                     align = "v",
                     ncol = 3, 
          axis = "t",
          rel_widths = c(1,0.5,0.6))   -> bottom.half.plot1
    
plot_grid(plotlist = list(ridges, bottom.half.plot1),
          align = "hv",
          ncol = 1, 
          nrow = 2,
          rel_heights = c(1,0.8),
          rel_widths = 1) 

plot_grid(plotlist = list(legend, boxplot.richness),
                     align = "hv",
                     ncol = 1, 
          axis = "t",
          rel_heights  = c(.5,1),
          labels = c(NA,"B" )) -> bottom.right

plot_grid (plotlist = list(map, bottom.right),
           align = "hv",
           nrow = 1,
           rel_heights = 1,
           rel_widths = c(.6,0.4),
           labels = c("A", NA)) -> bottom.plot

plot_grid(bottom.plot, ridges,
          align = "h",
          nrow = 2,
          rel_heights = c(0.6, 0.4),
          labels = c(NA,"C")) +
  ggsave(filename = here("Figures","Manuscript","Fig1.png"), width = 14, height = 14, dpi = "retina")

```

## Figure 2

To reuse for future analysis, create a function that does the fist step on a multivariate analysis: Create a horizontal matrix, a compatible matrix with the environmental data, and a dissimilarity object.

```{r functions for CAPS now without season}
cap.functions.only3things <- function(tibble, ...){ # ..  are the grouping factors
  
  tibble %>% 
    
    group_by(...) %>% 
    
    nest() %>% 
    
    mutate(comm.matrix = map (data, ~ tibble.to.table(.x, taxon = taxa, Abundance = Normalized.reads, sample.name = event)),
         
           ja = map(data, ~tibble_to_matrix(.x, taxon = taxa,Abundance = Normalized.reads, sample.name = event, distance = "jaccard",transformation = "binary" )),
          bc = map(data, ~tibble_to_matrix(.x, taxon = taxa,Abundance = Normalized.reads, sample.name = event, distance = "bray",transformation = "" )), # the bc distamce
          env = map (data, ~tibble_to_env(.x, taxon = taxa, Abundance = Normalized.reads, sample.name = event, everything()) %>% 
                       select(-contains("%")) %>% 
                       separate(event, into = c("Site", "Date"), sep = "_")))
}

```


We will do the Full CAP analysis - but will only keep Hood Canal for the MS - the rest will have to go to the Supplementary information

The figure will have three panels: the CAP for Hood Canal, the probability of presence of each cluster in the pH/Temperature space and the main contributors to the dissimilarity betweeen clusters.

```{r CAP analysis FULL}

data.plankton %>% 
  separate (event, into = c("Site", "Date"), sep = "_") %>% 
  mutate(Season = case_when(str_detect(Date,"17-03|17-10|17-11|18-01|18-03") ~ "Winter",
                             TRUE ~                                         "Summer"),
         Area = case_when(Site %in% c("CP","LK", "FH") ~ "San Juan Island",
                          TRUE                         ~ "Hood Canal")) %>% 
   unite (Site, Date, col = "event", sep = "_") %>% 
  cap.functions.only3things(Area) -> joined.dataset.for.CAP
```

Step by step
```{r CAP1}
joined.dataset.for.CAP %>% 
  mutate(
    CAP.analysys.raw = map2(comm.matrix, env,
                          
                          function(.x,.y) {
                            .y %>% select (Temperature, Salinity = Salinity.new, pH = pH_new) 
                            caps <-  capscale(formula = .x ~ Temperature + Salinity + pH ,
                                                 data = .y %>%
                                                   select(DIC = mean.DIC.new.sal, Salinity = Salinity.new, Temperature, pH = pH_new) %>% 
                                                   select_if(is.numeric) %>%
                                                   decostand(method = "standardize", na.action = na.omit),
                                                 distance = "jaccard", 
                                                binary = T)
         
                            sppscores(caps) <- sqrt(decostand(.x, "total"))
                              
                            return(caps) }),
         CAP.plot = map (CAP.analysys.raw, ~ plot(.x)),
         
         CAP.significance = map(CAP.analysys.raw, ~ permutest(.x, permutations = 999 )) ) -> joined.dataset.for.CAP

joined.dataset.for.CAP %>% pull(CAP.significance)
```

So the best numbers of clusters are  

```{r CAP2}
joined.dataset.for.CAP %>% mutate(plot3 =  map2 ( CAP.plot, Area, function(.x, .y) {fviz_nbclust(.x$sites,
                                                                             kmeans,
                                                                             k.max = 5,
                                                                             method = "wss") + ggtitle(paste0 (.y, "-WSS"))})) %>% pull(plot3)

joined.dataset.for.CAP %>% mutate(plot3 =  map2 ( CAP.plot, Area, function(.x, .y) {fviz_nbclust(.x$sites,
                                                                             kmeans,
                                                                             k.max = 5,
                                                                             method = "gap_stat") + ggtitle(paste0 (.y, " gap_stat"))})) %>% pull(plot3)

joined.dataset.for.CAP %>% mutate(plot3 =  map2 ( CAP.plot, Area, function(.x, .y) {fviz_nbclust(.x$sites,
                                                                             kmeans,
                                                                             k.max = 5,
                                                                             method = "silhouette") + ggtitle(paste0 (.y, "-Silhouette"))})) %>% pull(plot3)
```

These three methods would not agree on a "perfect" number of clusters - but using 3 clusters for both areas returned good scores in all three criteria.

So using 3 clusters - generate these clusters and join the datasets

```{r CAP2b}
joined.dataset.for.CAP %>%
  ungroup %>% 
  mutate(n_clust = c(3,3), 
  

  CAP.clusters = map2 (CAP.plot,n_clust,  function (.x, .y) {

    final <- kmeans(.x$sites, .y, nstart = 15)

    fviz_cluster(final, data = .x$sites, geom = "point", palette = "Set2")

  } ),

  Cluster.df = map2 (CAP.plot,n_clust,  function (.x, .y) {

    final <- kmeans(.x$sites, .y, nstart = 15)

    tibble(event = names(final$cluster),
           cluster = final$cluster) }

    )
  ) -> Clusters.analysis.and.cap


Clusters.analysis.and.cap %>% 
  mutate(full.cluster.info = map2(env, Cluster.df, ~ .x %>% unite(Site, Date, col = "event") %>%right_join(.y) ),
         full.cluster.info = map2(full.cluster.info,CAP.plot, ~ .y$sites %>% 
                                    as.data.frame() %>% 
                                    rownames_to_column("event") %>% 
                                    right_join(.x) %>% 
                                    mutate(pH = round(pH,1)))

         ) -> Clusters.analysis.and.cap

# Write out clusers and CAP points, and raw env data

Clusters.analysis.and.cap %>% 
  select(Area,  full.cluster.info) %>% 
  unnest() %>%
  write_csv(here("Output","clusters.of.events.csv"))

```

Now create the plot that combines Constrained Analysis of Principal Coordinates and clusterings
### Panel A: CAP analysis with environmnental correlation and cluster info
```{r Hand made CAP}



Clusters.analysis.and.cap %>% 
 
  mutate(Hand.made.CAP = map2(CAP.plot, full.cluster.info, function (.x, .y){
    
    
    .x$biplot %>%
                         as.data.frame() %>%
                        rownames_to_column("env.variable") -> var.scores
   
    .y %>% 
      select(event, CAP1, CAP2, cluster) %>% 
      ggplot(aes(x = CAP1,
                 y = CAP2)) +
      ggforce::geom_mark_hull(aes( group= cluster, color = as.factor(cluster),label = as.factor(cluster), fill = as.factor(cluster)),
                          expand = unit(2, "mm"),
                 label.margin = margin(1, 1, 1, 1, "mm"),
                 label.buffer = unit(0, "mm"),
                 con.cap = 1 ,
                 alpha = 0.5) +
     
      geom_point(size = 1.5) +
       geom_point(aes(color = as.factor(cluster)), size = 1) +
      geom_segment(aes(x = 0, y = 0,
                       xend = CAP1,
                       yend = CAP2), data = var.scores, color = "blue", arrow = arrow(length = unit(0.1,"cm"))) +
      geom_label_repel(aes(x= CAP1  ,
                           y= CAP2 ,
                           label = env.variable), data = var.scores, fill = "pink", alpha = 0.75) +
      ggtitle ("") + coord_equal() + scale_color_brewer(name = "Cluster", palette = "Set2") + scale_fill_brewer(name = "Cluster",palette = "Set2") +

      theme(legend.position = "bottom")
      

  })) %>% pull(Hand.made.CAP) -> leftplot.Fig2


 leftplot.Fig2 %>% set_names(Clusters.analysis.and.cap$Area) %>% map(~ .x +  theme_light() + theme(legend.position = "none") ) -> left_top

```

### Panel B: Cluster prevalence in the Temperature / pH space

We need the simulated data of the future conditions, and the cluster information.

```{r}
all.sim.data <- simData.nocrazys  #to see simulation data

clusters <- read.csv(here("Output","clusters.of.events.csv")) %>% 
  mutate(cluster  = as.factor(cluster)) %>% 
  nest(clusterdata = -Area)
```

Use a multinomial model to predict the cluster identity as a function of Temperature and pH.

```{r models and so for getting the communities}
clusters %>% 
  mutate (multi.mod = map (clusterdata, ~ multinom(cluster ~ Temperature + pH_new, data = .x))) -> clusters

```

Now create the prediction of the most likely community under each Temp-pH combination.

```{r models and so for getting the communities2}


  all.sim.data %>% 
    mutate (Area = fct_recode(Area, "San Juan Island" = 
                                "SJI")) %>% 
    group_by(Area) %>% 
    nest() %>% 
    mutate(pH.range = map(data, ~ seq(round(min(.x$pH_units),1), 
                                      round(max(.x$pH_units),1),
                                      length.out = 12)),
           T.range =  map(data, ~ seq(round(min(.x$TemperatureCelsius),1), 
                                      round(max(.x$TemperatureCelsius),1),
                                      length.out = 22)),
           output.range = map2(pH.range, T.range, ~ expand_grid(pH_new = .x, Temperature = .y))) %>% 
    
    left_join(clusters) %>% 
    mutate(whichComm.res = map2(output.range,multi.mod,~ .x %>% 
                                  mutate(comm = as.numeric (apply(predict(.y, type = "probs", newdata = .x),1, which.max)) )
              ) ,
           plots = map(whichComm.res, ~ 
                         ggplot(.x, aes(y = pH_new,
                                        x = Temperature,
                                        fill = as.factor(comm),
                                        )) +
                         geom_tile()+
                         geom_label(data = . %>% group_by(comm) %>% 
                                      summarise_all( mean),
                                    aes(x= Temperature,
                                        y= pH_new,
                                        label = comm),
                                    fill = "white")+
                         scale_fill_brewer(name = "Cluster", palette = "Set2") +
                         xlab("Temperature") + ylab("pH")+
                         theme_light())) -> testquick
  
testquick %>% pull(plots) %>% set_names(testquick$Area) %>% map(~ .x +  theme(axis.title.y = element_text(angle = 0),legend.position = "none") )-> center_top
```



### Panel C: For each cluster, follow the relative abundance of the taxa driving the differences

#### Generate the SIMPER clusters
```{r}
Clusters.analysis.and.cap %>% 
  mutate(SIMPER.clusters = map2(comm.matrix, Cluster.df, function(.x, .y) {
    
    simper(comm = .x,
          group = as.factor(.y$cluster),
          permutations = 999)
    
  })) %>% 
  select(Area, SIMPER.clusters) -> SIMPER.clusters 

SIMPER.clusters %>% 
  mutate(summary.simper = map(SIMPER.clusters, ~ summary(.x, ordered  = TRUE) )) %>% 
  mutate(taxa.simper = map(summary.simper, ~ map(.,function(x) rownames_to_column(x, var = "taxa") %>% pull(var = taxa)   )[[1]])) -> SIMPER.clusters


SIMPER.clusters %>% 
  mutate(summary.simper = map(summary.simper,function(.x) bind_rows(.x[1:length(.x)], .id = "comparison") %>% rownames_to_column("taxa"))) %>% pull(summary.simper) %>% set_names(SIMPER.clusters$Area) %>% bind_rows(.id = "Area") %>% separate(taxa, into = c("taxa",NA), sep = "\\...") %>% 
  filter (p < 0.05) %>% 
  write_csv(here("Output","simper.all.csv"))


## Get the data for all seasons and areas
 SIMPER.clusters %>%
   pull(summary.simper)-> list.of.simpers
names(list.of.simpers) <- paste(SIMPER.clusters$Area, SIMPER.clusters$Season, sep = "_")

 list.of.simpers %>%
  map(~ .x %>% map(~ bind_rows(.)) %>% 
                          bind_rows(., .id = "Comparison")) %>% 
  bind_rows(., .id = "var1") %>%
   separate(var1, into = c("Area", "Season"), sep = "_") %>%
   select(-Season) %>% 
   group_by(Area,  Comparison) %>% 
   nest() %>% 
   left_join(SIMPER.clusters) %>%
   mutate(data = map2(data, taxa.simper, ~bind_cols(.x, as_tibble(.y)))) %>% 
   select(Area,  Comparison, data) %>% 
   unnest(data) %>% 
  # rename(taxa = value) %>% 
  write_csv(here("Output","simper.all.csv") )
   

  
```
#### Now do the topright
 get the data and plt a distribution of the average contributions of each taxa for each 
```{r}
taxa.to.follow <- read_csv(here("Output","simper.all.csv")) 
 

taxa.to.follow %>% 
  ggplot(aes(x = average)) + 
  geom_histogram() +
  facet_grid(Area ~ Comparison)
```


### Choose a threshold of 0.01 for average contribution



```{r}
taxa.to.follow %>% 
  filter (p<0.01, average > 0.01) %>%  
  arrange(desc(average)) %>% 
  group_by(Area, Comparison) %>% 
    slice(1:5) %>% 
  
  transmute(Area, Comparison, taxa = value, diff = avb - ava, average = case_when(ava > avb ~ average, TRUE ~ -average), sd) %>% 
  left_join(phylum.info %>% select(phylum,taxa)) %>% 
  separate(taxa, into = c("family","genus", "species"), sep = "\\|", remove = F) %>%
  mutate(label = case_when((species == "NA" & genus == "NA") ~ paste0(family, " sp."),
                           species == "NA" ~  paste0(genus, " sp."),
                           TRUE            ~ species)) %>%
  mutate(label2 = paste(phylum, label, sep = " | ")) %>% 
  mutate(Comparison = fct_relabel(Comparison, ~ str_replace(.,"_", " vs "))) %>% 
  nest(-Area) %>% 
  mutate(plot = map(data, function(.x){
    lims = c(-max(abs(.x$average) + (.x$sd)), max(abs(.x$average) + (.x$sd)))
    ggplot(.x, aes(y = average,
             x = fct_reorder(label2, average))) +
  geom_col(aes(fill = diff>0), size = 0.5, color = "black") +
      geom_errorbar(aes(ymin = average -sd, ymax = average + sd ), width = 0.25) +
  geom_hline(yintercept = 0, color = "black")+
  labs (x = "taxa",
        y = "Contribution to dissimilarity")+
  coord_flip(ylim=lims) +
    scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
  facet_wrap(~Comparison) +
  guides(fill = "none") +
    
 
    theme_light() + theme(axis.text.y = element_text(face = "bold.italic", colour ="#3B4252", hjust = 0 ),
                          strip.background = element_rect(fill = "#3B4252"),
                          strip.text = element_text(face = "bold", color = "#EBCB8B"))} 
  ))   -> right_most
  
right_most %>% pull(plot) %>% set_names(right_most$Area) -> right_top
right_top
```


### Final Figure 2

Here is the code for the figure that goes in the MS - the San Juan Island's is on the next chunk of code.

```{r assembling Figure 2}



left_top[["Hood Canal"]] + theme(legend.position  = "right", 
                                 axis.title.y = element_text(vjust = 0.5, angle = 0))  -> p1
 center_top[["Hood Canal"]] + theme(axis.title.y = element_text(vjust = 0.5, angle = 0)) -> p2
 right_top[["Hood Canal"]] +  theme(axis.title.y = element_blank())-> p3

layout5 <-c(
  patchwork::area(t= 1, l=1 , b=6 , r=4),
  patchwork::area(t= 7, l=1 , b=11 , r=4),
 # area(t= 5, b=5, l=4),
  patchwork::area(t= 1, l= 6, b= 11, r=9)
) 

plot(layout5)
p1 + 
  p2 +
  # guide_area()+ 
  p3 + plot_layout(design = layout5) + plot_annotation(tag_levels = "A")  -> plot


ggsave(plot,filename = here("Figures","Manuscript",paste0("Figure2.", Sys.Date(), ".png")),
         width = 14,height = 11, dpi = "retina") 

```

```{r assembling Figure for Supplementary material}

left_top[["San Juan Island"]] + theme(legend.position  = "right")  -> p1
 center_top[["San Juan Island"]] -> p2
 right_top[["San Juan Island"]] -> p3
p1 + 
  p2 +

  p3 + plot_layout(design = layout5) + plot_annotation(tag_levels = "A")  -> plot

ggsave(plot,filename = here("Figures","Supplementary",paste0("Supp.info.San.Juan.Island.Fig2", Sys.Date(), ".png")),
         width = 14,height = 11, dpi = "retina") 

```


## Figure 3: a quick glance at spp responses
Get the models output and calculate the posterior across the simulated scenario

Now, calculate the posterior of each taxa across the 16,276 scenarios simulated

### Posterior per taxa per point in the future

We use the climate projection to predict changes in suitability 

```{r}


all.sims.for.projection <- simData.nocrazys %>% 
  select(Area, Year, Temperature, TemperatureCelsius, pH, pH_units) 

## Get 
models %>% 
  transmute(taxa, 
            post.draws = map2 (model, taxa, ~ posterior_predict(object = .x,
                                                                newdata = all.sims.for.projection,
                                                                draws = 100) %>% 
                                 as_tibble() %>% 
                                 t(.) %>% 
                                 as_tibble() %>% 
                                 rownames_to_column("sim.row") )) -> posterior.draws.all

# This is an object with as many rows as environmental points there are. The first two columns are taxa and nrow. The rest are the binary output of the posterior
# predict

posterior.draws.all %>% 
 left_join(phylum.info %>% dplyr::select(phylum, taxa)) %>% 
  group_by(phylum) %>% # Add phylum information
  nest() %>% 
   mutate (data = map (data, ~ .x %>% 
                        unnest() %>% 
                        pivot_longer(cols = c(-taxa, -sim.row),
                                    names_to = "draw.row", values_to = "presence") %>% 
  group_by(taxa, sim.row) %>% 
  summarise(prob.of.presence = mean(presence)) %>% 
  left_join(all.sims.for.projection %>%  
              rownames_to_column("sim.row")) 

  )) -> posterior.probabilities.by.taxa
```
Now we have a nested dataframe per each phylum. Not that we need it. But the nested part is a dataframe with the mean result of the 100 draws for each environmental point.

### Richness by phyla with time
 First create the square matrix of points - the ggplot geometries requires one entry per grid - so we have to comply
```{r create full grid}
 
all.sims.for.projection  %>% 
  group_by(  Area) %>% 
  # filter (keep == "keep") %>%   
  summarise_at(c("TemperatureCelsius", "pH_units"), list(max = max, min = min)) %>% 

  group_by ( Area) %>% 
  nest() %>% 
  mutate(data = map (data, ~ expand_grid(TemperatureCelsius = seq(round(.x$TemperatureCelsius_min,1), round(.x$TemperatureCelsius_max, 1),by = 0.1),
                                         pH_units = seq(round(.x$pH_units_min,1), round(.x$pH_units_max,1), by = 0.1)))) %>% 
  unnest(data) -> full.grid
```


```{r add standarized temperatures to the grid}

full.grid %>% 
  ungroup() %>% 
  rownames_to_column("Case") %>% 
  rename(Temperature = TemperatureCelsius,
         pH = pH_units) %>% 
  
  pivot_longer(cols = c(Temperature, pH),
               names_to  = "Predictor",
               values_to = "value") %>% 
  group_by(Area, Predictor) %>% 
  nest() %>% 
  left_join(transforming.df) %>% 
  mutate(data = map2(data, to.std, ~.x %>% 
                       mutate(std = .y[1]+.y[2]*value ))) %>% 
  select(Area, Predictor, data) %>% 
  unnest(data) %>% 
  pivot_wider(names_from = Predictor,
              values_from = c(std,value)) %>% 
  rename(Temperature = std_Temperature,
         pH = std_pH,
         TemperatureCelsius = value_Temperature,
         pH_units           = value_pH) -> full.grid
```

`full.grid` has the temperature and pH values we want to project our models to - so now we use it with the `models` output. 

```{r calculate the 100 draws from the posterior}
models %>% 
  ungroup() %>%  #rpk added
  transmute(taxa, 
            post.draws = map2 (model, taxa, ~ posterior_predict(object = .x,
                                                                newdata = full.grid,
                                                                draws = 100) %>% 
                                 as_tibble() %>% 
                                 t(.) %>% 
                                 as_tibble() %>% 
                                 rownames_to_column("sim.row") )) -> posterior.draws.raster
```


```{r calculate richness}
posterior.draws.raster %>% 
 left_join(phylum.info %>% dplyr::select(phylum, taxa)) %>% 
  group_by(phylum) %>% 
  nest() %>% 
  mutate(data = map (data, ~ .x %>% unnest(cols= post.draws) %>% 
                       pivot_longer(cols = c(-taxa, -sim.row),
                                    names_to = "draw.row", values_to = "presence") %>% 
                       group_by(draw.row, sim.row) %>% 
                       summarise(tot = sum(presence)) %>% 
                       group_by(sim.row) %>% 
                       summarise_at(.vars = "tot", .funs = list(Richness = mean,sd = sd)))) %>% 
  unnest(data) -> ready_plot

ready_plot %>% 
  left_join(full.grid %>%  
              rownames_to_column("sim.row")) -> ready_plot

# Normailzed the data for each phyla

ready_plot %>% 
  group_by(phylum) %>% 
  mutate(st.richness = Richness / max(Richness)) -> ready_plot

```
 
 
```{r plot3 function}
plot3 <- function(tibble,string , response) {
  
  response = enquo(response)
  
  
  tibble %>% 
    ungroup() %>% 
    mutate(Area = as.character(Area)) %>% 
    mutate(Area = case_when(Area == "SJI" ~ "San Juan Island",
                            TRUE          ~ Area)) %>% 
    group_by(TemperatureCelsius, pH_units, Area) %>% 
   
    summarise (!!response := mean (!!response))  %>% 
  
    ggplot(aes(x = round(TemperatureCelsius,10),
             y = round(pH_units, 10))) +
  
  geom_raster( interpolate = T,aes( fill = !!response)) +
  
  scale_fill_distiller(name = "Standarized Richness", type = "seq", palette = "Spectral",limits=c(0,1) ) +
  
  # geom_density2d(data = simData %>%
  #                   filter (Year %in% c(2015, 2095)),
  #                 aes(x= TemperatureCelsius, y = pH_units, group= Year, color = as.factor(Year)), bins = 5, alpha = 0.5) +
 
  scale_color_brewer(name = "Year",  type = "qual", palette = 4, direction = -1, breaks=c("2017","2095")) +
  ggforce::geom_mark_hull(data = all.sims.for.projection %>%
                            ungroup() %>%
                            mutate(Area = as.character(Area)) %>% 
                            mutate(Area = case_when(Area == "SJI" ~ "San Juan Island",
                            TRUE          ~ Area)) %>%
                            filter (Year %in% c(2017, 2095)) ,
                          aes(x= TemperatureCelsius, y = pH_units, group= Year, color = as.factor(Year),label = as.factor(Year)),
                          expand = unit(0.5, "mm"),
                 label.margin = margin(1, 1, 1, 1, "mm"),
                 label.buffer = unit(0, "mm"),
                 con.cap = 0 ,
                 alpha = 0.5) +
     facet_grid(.~Area) +
  guides(color = "none") +
    labs (x = "Temperature",
          y= "pH") +
    theme_minimal()+
    theme(legend.position = "bottom",
          legend.key.width  = unit(2 ,"cm"),
          axis.title.x = element_text(face = "bold"),
          legend.direction = "horizontal") +
    scale_x_continuous(position = "top")
  
  
}
```
 
```{r}
ready_plot %>% 
  nest(-phylum) %>% 
  mutate(plot = map2(data, phylum, ~ plot3(.x, .y, response = st.richness)))  -> list.of.richness.plots

```

```{r}

list.of.richness.plots %>%  pull(phylum) -> list.of.phyla


list.of.richness.plots %>% pull(plot) -> list.of.raster.plots

list.of.raster.plots <- set_names(list.of.raster.plots, nm = list.of.phyla)


```

# Assembling Figure 3

Following reviewer's suggestions, we are limiting the information displayed in the main Figures to two of most important phyla for coastal ecosystems dinamics: Diatoms and Dinoflagellates.


```{r select some }
posterior.probabilities.by.taxa %>% 
  ungroup() %>% 
  filter (phylum %in%c("Dinophyceae", "Bacillariophyta")) %>% 
  mutate(suma = map (data,~.x %>% group_by(taxa,Area, Year) %>%
                       summarise(tot = sum(prob.of.presence)) %>%
                       ungroup() %>% 
                       pivot_wider(names_from = Year, values_from = tot) %>% 
                        group_by(taxa) %>% mutate(diff = `2017` - `2095`)
                     )) %>% 
  select(phylum, suma) %>% 
  unnest(suma) %>%
  group_by(phylum) %>% arrange(desc(abs(diff))) %>% 
  separate(taxa, into = c("family","genus", "species"), sep = "\\|", remove = F) %>%
  mutate(label = case_when((species == "NA" & genus == "NA") ~ paste0(family, " sp."),
                           species == "NA" ~  paste0(genus, " sp."),
                           TRUE            ~ species)) -> taxa.and.diff

taxa.and.diff %>%
  slice(1:5) %>%
  arrange(diff) %>% pull(taxa) -> ahorasi

taxa.and.diff %>% 
  slice(1:5) %>%
  arrange(diff) %>% pull(label) -> reorder.labels

# Write to file the posterior probabilietes by taxa so Ryan can play with it
# posterior.probabilities.by.taxa %>% 
#   unnest(data) %>% 
#   write_csv(here("Output", "posterior.probability.by.taxa.csv"))
```

```{r the final one}

posterior.probabilities.by.taxa %>%

ungroup() %>%
filter (phylum %in%c("Dinophyceae", "Bacillariophyta")) %>%
mutate( plot.by.taxa = map2 (data, phylum, ~ .x %>%
filter(taxa %in% ahorasi) %>% 
separate(taxa, into = c("family","genus", "species"), sep = "\\|", remove = F) %>%
mutate(label = case_when((species == "NA" & genus == "NA") ~ paste0(family, " sp."),
species == "NA" ~  paste0(genus, " sp."),
TRUE            ~ species))    %>%
mutate(Area = as.character(Area)) %>%
mutate(Area = case_when(Area == "SJI" ~ "San Juan Island",
TRUE          ~ Area)) %>%
mutate(Year = fct_rev(as.factor(Year) )) %>%
ggplot(aes(x= prob.of.presence,
y = fct_relevel(label,reorder.labels))) +
#   geom_violin(aes(fill= (Year)), weight = 2, adjust = 1, draw_quantiles =  0.5, scale = "count")+
scale_fill_brewer(name = "Year",  type = "qual", palette = 4, direction = 1, breaks=c("2017","2095")) +
labs (x = "Probability of presence",
y = "") +
facet_wrap(~Area, ) +
theme_minimal() +
theme(strip.text.y = element_text(angle = 0),
axis.text.y = element_text(face = "italic"),
legend.direction = "horizontal",
legend.position  = "bottom",
plot.title.position = "plot",
plot.title = element_text(face = "bold",vjust =  -5 ),
axis.title.x.top  = element_text(face = "bold",vjust = 3) ) +
ggtitle(.y)  +
scale_x_continuous(limits = c(0,1),position = "top") )) %>%
pull(plot.by.taxa) %>% set_names(.$phylum) -> fig3.left
  
map(fig3.left, function(x) x+ geom_boxplot(aes(fill = as.factor(Year)))) -> fig3.left

posterior.probabilities.by.taxa %>%
ungroup() %>%
filter (phylum %in%c("Dinophyceae", "Bacillariophyta")) %>%
  pull(phylum) %>%
  set_names(fig3.left, .) -> fig3.left

list.of.raster.plots[c("Dinophyceae", "Bacillariophyta")] -> fig3.right



layout <- "
AA
AA
FF
EE
EE
GG
"


wrap_plots(A = fig3.left[["Dinophyceae"]] +   labs(tag = "A"),
           F = plot_spacer(),
           E = fig3.left[["Bacillariophyta"]] ,
           G = guide_area(),
            design = layout, heights = c(5,5,1,5,5,5), guides = "collect") -> left

layout2 <- "
#BB
#BB
JJJ
#HH
#HH
III
"
wrap_plots(B = fig3.right[["Dinophyceae"]] +   labs(tag = "B"),
           J = plot_spacer(),
           H = fig3.right[["Bacillariophyta"]] ,
           I = guide_area(),
            design = layout2,heights = c(5,5,1,5,5,5),
           widths = c(1,2,2), guides = "collect") -> right

(left|right)+plot_layout(widths = c(2,3))  -> plot 
   ggsave(plot , filename = here("Figures","Manuscript", paste0("Top_fig3_",Sys.Date(),".Other.sel.png")), units = "in", dpi = "retina", width = 20, height = 12)
 
```

#### Bonus track:Create phylum-specfic plots for Supplementary Information

```{r}
posterior.probabilities.by.taxa %>% 
  ungroup() %>% 
  # filter (phylum %in%c("Dinophyceae", "Bacillariophyta")) %>% 
  mutate(suma = map (data,~.x %>% group_by(taxa,Area, Year) %>%
                       summarise(tot = sum(prob.of.presence)) %>%
                       ungroup() %>% 
                       pivot_wider(names_from = Year, values_from = tot) %>% 
                        group_by(taxa) %>% mutate(diff = `2017` - `2095`)
                     )) %>% 
  select(phylum, suma) %>% 
  unnest(suma) %>%
  group_by(phylum) %>% arrange(desc(abs(diff))) %>% 
  separate(taxa, into = c("family","genus", "species"), sep = "\\|", remove = F) %>%
  mutate(label = case_when((species == "NA" & genus == "NA") ~ paste0(family, " sp."),
                           species == "NA" ~  paste0(genus, " sp."),
                           TRUE            ~ species)) -> taxa.and.diff

taxa.and.diff %>%
  slice(1:5) %>%
  arrange(diff) %>% pull(taxa) -> ahorasi

taxa.and.diff %>% 
  slice(1:5) %>%
  arrange(diff) %>% pull(label) -> reorder.labels
```


```{r}
posterior.probabilities.by.taxa %>%

ungroup() %>%
mutate( plot.by.taxa = map2 (data, phylum, ~ .x %>%
#filter(taxa %in% ahorasi) %>% 
separate(taxa, into = c("family","genus", "species"), sep = "\\|", remove = F) %>%
mutate(label = case_when((species == "NA" & genus == "NA") ~ paste0(family, " sp."),
species == "NA" ~  paste0(genus, " sp."),
TRUE            ~ species))    %>%
mutate(Area = as.character(Area)) %>%
mutate(Area = case_when(Area == "SJI" ~ "San Juan Island",
TRUE          ~ Area)) %>%
mutate(Year = fct_rev(as.factor(Year) )) %>%
ggplot(aes(x= prob.of.presence,
# y = fct_relevel(label,reorder.labels))) +
 y = label)) + 
#   geom_violin(aes(fill= (Year)), weight = 2, adjust = 1, draw_quantiles =  0.5, scale = "count")+
scale_fill_brewer(name = "Year",  type = "qual", palette = 4, direction = 1, breaks=c("2017","2095")) +
labs (x = "Probability of presence",
y = "") +
facet_wrap(~Area, ) +
theme_minimal() +
theme(strip.text.y = element_text(angle = 0),
axis.text.y = element_text(face = "italic"),
legend.direction = "horizontal",
legend.position  = "bottom",
plot.title.position = "plot",
plot.title = element_text(face = "bold",vjust =  -5 ),
axis.title.x.top  = element_text(face = "bold",vjust = 3) ) +
ggtitle(.y)  +
scale_x_continuous(limits = c(0,1),position = "top") )) %>% 

pull(plot.by.taxa)   -> Suppl.Material.plots
  
map(Suppl.Material.plots, function(x) x+ geom_boxplot(aes(fill = as.factor(Year)))) -> Suppl.Material.plots

posterior.probabilities.by.taxa %>%
ungroup() %>%
  pull(phylum) %>%
  set_names(Suppl.Material.plots, .) -> Suppl.Material.plots

list.of.raster.plots[[1]]

names(Suppl.Material.plots) == names(list.of.raster.plots)


map2(Suppl.Material.plots, list.of.raster.plots, 
     function(.x,.y){
       
       .x  +plot_spacer()+ .y + plot_layout(widths = c(4,1,4)) -> plot
         
        return(plot)
       
     }) -> Suppl.Material.plots.final

names (Suppl.Material.plots.final) <- names(Suppl.Material.plots)
map2 (Suppl.Material.plots.final,names(Suppl.Material.plots.final),   ~ ggsave(plot = .x, filename = here("Figures","Supplementary",paste0("Supp.fig",.y,".png")),device = "png",
                units = "in", dpi = "retina", width = 20, height = 12)
                                                                               )
```
